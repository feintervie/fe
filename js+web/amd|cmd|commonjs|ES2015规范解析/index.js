commonjs规范

一个文件就是一个模块，拥有单独的作用域。普通方式定义的变量、函数、对象都属于这个模块。

1. 通过require来加载模块
2. 通过exports和module.exports来暴露模块中的内容

- commonjs的模块输出是一个值的拷贝，ES6模块输出的是值的引用
- commonjs模块是运行时加载，ES6模块是运行时输出接口；

主要原因是commonjs加载的是一个对象（即module.exports属性）该对象只有在脚本运行完才会生成。
ES6模块不是对象，它的对外接口只是一种静态的定义，在代码静态解析阶段就会生成。





ES2015的模块规范

1. 一个文件就是一个单独的模块。该文件内部的所有变量，外部无法获取
2.export 命令用户规定模块的对外接口
3.import 命令用于输入其它模块提供的功能
4.ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量



AMD模块规范


1.AMD 通过异步加载模块。模块加载不影响后面语句的执行。所有依赖某些模块的语句均放置在回调函数中。
2.AMD 规范之定义了一个函数define ,通过define方法定义的模块，


define(id?, dependencies?, factory)
id：指定义中模块的名字（可选）。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。
dependencies：当前模块依赖的，已被模块定义的模块标识的数组字面量（可选）。
factory：一个需要进行实例化的函数或者一个对象。



CMD规范


1.对于依赖的模块 CMD 是延迟执行，而 AMD 是提前执行（不过 RequireJS 从 2.0 开始，也改成可以延迟执行。 ）
2.CMD 推崇依赖就近，AMD 推崇依赖前置。
3.AMD 的 api 默认是一个当多个用，CMD 严格的区分推崇职责单一，其每个 API 都简单纯粹。例如：AMD 里 require 分全局的和局部的。CMD 里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。

