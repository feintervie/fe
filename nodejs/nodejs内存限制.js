// V8限制了nodejs每个进程的最大内存：64系统1.4G，32位系统0.7G, 这个大小的限制在chrome里面已经够用了，但在服务端nodejs感觉可能不够用。
// 为什么这样限制? 如果内存超过1.5G时 做一次全量垃圾回收，耗时在1秒左右，这1秒时间内，进程是暂停执行的，对于高平发，高流量的服务影响会很大。


// 解决Nodejs内存限制的方法， 使用多进程

// --max-old-space-size和--max-new-space-size 这两个启动参数来增加进程对内存的使用


新生代内存 存活时间较短的对象,使用空间换时间的内存回收算法 （活对象只占较少的部分）

新生代内存被一分为2，一个处于使用中(from空间），一个处于闲置的状态（to空间）。当我们分配对象时先
在from空间进行分配。当开始进行垃圾回收时，会检查from空间中的存活的对象，这样存活的对象将被复制到to空间
中，而非存活的对象占用的空间将会被释放。完成复制后，from空间和to空间的角色发生对换。




老生代内存 存活时间较长，或者是常驻内存的对象。声明周期较长的对象 （死对象只占较少的部分）

新生代内存晋升为老生代内存的条件：
1. 对象是否经历过新生代内存算法的回收，
2. to空间的内存占用比超过限制  （如果内存占用超过了25%，就直接向新生代对象晋升到老生代内存空间中）


老生代内存回收的策略：

老生代内存采用标记清楚地方式进行垃圾回收。分为两个阶段

1. 标记阶段  遍历堆中的所有对象，并标记活着的对象
2. 清除阶段  只清除没有标记的对象



老生代的内存空间会出现内存碎片的问题，当要存储一个较大的对象时，可能会提前触发垃圾回收。

在标记阶段，标记为死亡的对象后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。




为什么避免出现JS应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收算法在执行的时候都会将应用的
逻辑暂停下来，待执行完垃圾回收后再回复执行应用逻辑。这种行为被称为“全停顿”。
